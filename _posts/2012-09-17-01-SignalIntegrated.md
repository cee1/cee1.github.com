---
layout: post
title: "信号完整性测试工具完善"
description: "这个工作完全是补历史的帐。开始是协助测试做这一块的东西。信号完整性测试这个名字看起来很唬人的，其实在软件上来看就是设置几个寄存器，然后通过硬件工具测量PHY口信号变化是否正常，在这个地方接触所说的眼图的定义。不过我对这东西的理解也就是从图片上分辨好or坏的样子。"
category: "工作完善"
tags: [Signal Integrated]
---
{% include JB/setup %}

这个工作完全是补历史的帐。开始是协助测试做这一块的东西。信号完整性测试这个名字看起来很唬人的，其实在软件上来看就是设置几个寄存器，然后通过硬件工具测量PHY口信号变化是否正常，在这个地方接触所说的眼图的定义。不过我对这东西的理解也就是从图片上分辨好or坏的样子。   
**工具的历史的变迁：**  
说到完善就要回顾历史了，最开始设置寄存器是在KERNEL MODE设置的，写一个小的kernel module。要测试的时候就 insmod si_module xxxx。xxxx的意思就是可以传递的控制参数。用起来发现非常不方便，敲一段很长的命令，这对不熟悉Linux的是一个挑战;而且每次换内核后，这个模块不能使用了，还得rebuild。有时候有抓狂的感觉。  
想到直接通过用户程序去操作寄存器不是能够规避上面的问题了，于是用mmap通过/dev/mem文件映射设备的物理地址，能够正常完成了。后面就没有去管了！   
随着项目的增多，发现还是麻烦，每次都要去cat /proc/iomem然后翻寄存器手册，然后计算好值，然后写入。中间将mmap的功能增强了一些，通过脚本文件将每个机器的要测试的写好，然后测试人员可以直接点击脚本文件运行。反正中间也写了很多个版本，不过都没有下文了。而long long ago，我开始参与Android项目。   
今年又开始参与服务器项目，测试部又找上门来了。终于下决心就这个东西好好弄一下。 弄之前，想了一下原来的问题列出了**几个要求： **    
**1**：可扩展性好   
**2**：用户可用性高   
**3**：代码可重用性高   

最后将这几个要求有具体化了一下，变成下面的样子了。   
**1**：可扩展性   
如果相同操作的话，直接通过配置文件添加一个支持设备的设备号就能完成。
如果是一个新设备的话，能够直接通过接口非常容易的添加操作处理。
考虑到特定设备设置时的特殊性
比如有些设备需要先设置成这个样子，然后再设置它的模式才能正常工作
考虑到特定设备设置前的特殊
比如某些设备的地址是从Base1或者Base2开始计算的

**2**：用户可用性高   
目前想到的一个方案为：
用户如果测试网卡 则输入网卡 ./si_bin  --netcard 回车，然后列出系统中可用的网卡,并等待用户的输入选择哪个，选择好后，回车提示哪种测试模式，选择好后，回车开始测试。   
如果测试SATA，./si_bin --sata回车，然后列出系统中可用的sata控制器，选择完后列出哪个slot测试，选好后，列出测试模式，选择哪个测试模式。选好后开始测试。   
如果测试USB，./si_bin --usb回车，列出系统中可用的usb控制器，选择好后，列出控制器控制的port口，选好后，列出测试模式选择，选择好后 开始测试。

**3**：代码可重用性高  
重复性质的代码要少。

考虑到我们项目中重复使用到的chipset比较多，而且升级也是使用同一个系列的，很多操作其实也是大同小异。故整个结构使用内核的driver与device匹配的方法，一个driver支持多个设备。因为考虑到用C语言写的，编译好后不能修改，故添加了一个配置文件来说明driver支持的设备。最后就是 main.c处理用户参数然后将所有driver以及他支持的设备进行绑定，然后根据用户输入的参数将所有的同类型设备都列出来，方便用户选择。interface.c提供读写寄存器的方法。driver.c处理整个与driver相关的操作。其他就是特定的driver，里面实现一个driver的结构体就可以了。如果很多设备的操作都一样则只要实现一个driver，然后将设备号写入到配置文件就OK了。即使有新的设备进来，因为整个driver的结构设计的非常简单，只要稍微添加一点东西就OK了。

完成部分后，给测试人员使用，评价是比较好的。后面这个东西可以直接交给测试部去维护了。Thank Goodness, I am free!!!
